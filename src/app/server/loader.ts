/*
	Copyright 2022 cpuabuse.com
	Licensed under the ISC License (https://opensource.org/licenses/ISC)
*/

/**
 * Performs loading of the server.
 *
 * @file
 */

import { promises as fs } from "fs";
import axios from "axios";
import { DeferredPromise } from "../common/async";
import { appUrl } from "../common/defaults";
import { UrlPath } from "../common/url";
import { hasOwnProperty } from "../common/utility-types";
import { Application } from "../core/application";
import { CoreArgIds, CoreArgMeta, coreArgMetaGenerate } from "../core/arg";
import { CoreShardArg } from "../core/shard";
import { RootType, compile } from "../yaml/compile";
import { YamlOptions, yamlOptions } from "../yaml/options";
import { Module, ModuleFactoryRecordList, ModuleFactoryRecordListConstraint, ModuleList } from "./module";
import { ServerOptions, serverOptions } from "./options";
import { ServerUniverse } from "./universe";

/**
 * Yaml entry types.
 */
export enum YamlEntryType {
	File = "file",
	Url = "url"
}

/**
 * Yaml entry to register into loader.
 */
export type YamlEntry = {
	/**
	 * Path to yaml file or URL.
	 */
	path: string;

	/**
	 * Path type.
	 */
	type: YamlEntryType;
};

/**
 * Loader class.
 */
export class ServerLoader<T extends ModuleFactoryRecordListConstraint<T>> {
	/**
	 * Application this resides in.
	 */
	private application: Application;

	/**
	 * Default yaml file.
	 */
	private static defaultYaml: string = "";

	/**
	 * Factory records from constructor.
	 */
	private records: ModuleFactoryRecordList;

	/**
	 * UUIDs are not used, as they are not generated by the application for client.
	 */
	private yamlList: Map<string, YamlEntry> = new Map();

	/**
	 * Adds modules to loader.
	 *
	 * @param list - List of module factory records
	 * @remarks
	 * Safety comes from type constraint, so unnecessary checks omitted.
	 * By design, depends might contain irrelevant keys, and this function accounts for that.
	 */
	public constructor({
		application,
		records,
		yamlList
	}: {
		/**
		 * Application.
		 */
		application: Application;

		/**
		 * Factory records list.
		 */
		records: T;

		/**
		 * List of yaml files.
		 */
		yamlList: {
			[key: string]: YamlEntry;
		};
	}) {
		this.application = application;
		// Reverting from generic to concrete type
		this.records = records as unknown as ModuleFactoryRecordList;
		this.yamlList = new Map(Object.getOwnPropertyNames(yamlList).map(key => [key, yamlList[key]]));
	}

	/**
	 * Add server universe.
	 *
	 * @param param - Destructured parameter
	 * @returns Created universe
	 */
	public async addUniverse({
		yamlId
	}: {
		/**
		 * ID of YAML.
		 */
		yamlId: string;
	}): Promise<ServerUniverse> {
		/**
		 * List of kinds to register IDs.
		 */
		type KindList = Partial<Record<string, Partial<Record<string, string>>>>;

		const universeCreated: DeferredPromise<void> = new DeferredPromise();
		const universe: ServerUniverse = this.application.addUniverse({
			Universe: ServerUniverse,
			args: [{ created: universeCreated }]
		});
		await universeCreated;

		const yamlEntry: YamlEntry | undefined = this.yamlList.get(yamlId);
		let data: string;
		try {
			switch (yamlEntry?.type) {
				case YamlEntryType.File:
					data = await fs.readFile(yamlEntry.path, "utf8");
					break;
				case YamlEntryType.Url:
					data = (await axios.get<string>(yamlEntry.path, { responseType: "text" })).data;
					break;
				default:
					throw new Error("YAML entry missing");
			}
		} catch {
			data = (ServerLoader.constructor as typeof ServerLoader).defaultYaml;
		}
		const root: RootType = compile({ data });
		// Module to kind name to ID
		// eslint-disable-next-line @typescript-eslint/typedef
		const kindList: KindList = Object.entries(root.kinds).reduce((result, [id, { module, name }]) => {
			let newResult: KindList = result;
			if (!hasOwnProperty(newResult, module)) {
				newResult[module] = {
					[name]: id
				};
			} else {
				newResult[module][name] = id;
			}

			return newResult;
		}, {});
		let moduleList: ModuleList = {};

		// Iterate through records
		this.records.forEach(record => {
			const {
				name: moduleName
			}: {
				/**
				 * Name of module.
				 */
				name: string;
			} = record;
			const module: Module = record.factory({
				// False negative on type inference
				// eslint-disable-next-line @typescript-eslint/typedef
				modules: Object.entries(record.depends).reduce((result, [key, value]) => {
					return { ...result, [key]: moduleList[value] };
				}, {} as ModuleList),
				universe
			});
			const kindListEntry: KindList[string] = kindList[moduleName];
			const moduleKinds: Module["kinds"] = module.kinds;

			// Populate module list
			moduleList[moduleName] = module;

			// Register kinds
			Object.keys(moduleKinds).forEach(kindName => {
				let id: string;
				let namespace: UrlPath;
				let kindId: string | undefined;
				// Using assignment inside condition simplifies logic dramatically
				// eslint-disable-next-line no-cond-assign
				if (kindListEntry && (kindId = kindListEntry[kindName])) {
					id = kindId;
					namespace = "user";
				} else {
					id = kindName;
					namespace = `kind/${moduleName}`;
				}

				universe.Entity.addKind({ Kind: module.kinds[kindName], id, namespace });
			});
		});

		await Promise.all(
			root.data.shards.map(
				(shard, index) =>
					new Promise<void>(methodResolve => {
						// Add shards
						let attachHook: Promise<void> = new Promise((resolve, reject) => {
							let created: DeferredPromise<void> = new DeferredPromise<void>();
							setImmediate(() => {
								let meta: CoreArgMeta<CoreArgIds.Shard, YamlOptions, ServerOptions> = coreArgMetaGenerate({
									id: CoreArgIds.Shard,
									index,
									meta: {
										origin: appUrl,
										paths: {},
										systemNamespace: "system",
										userNamespace: "user"
									},
									sourceOptions: yamlOptions,
									targetOptions: serverOptions
								});
								let arg: CoreShardArg<ServerOptions> = universe.Shard.convertShard({
									meta,
									shard,
									sourceOptions: yamlOptions,
									targetOptions: serverOptions
								});

								universe.addShard(arg, { attachHook, created }, []);

								created
									.then(() => {
										resolve();
									})
									.catch(() => {
										reject();
									})
									.finally(() => {
										methodResolve();
									});
							});
						});
					})
			)
		);

		return universe;
	}
}
