/*
	Copyright 2023 cpuabuse.com
	Licensed under the ISC License (https://opensource.org/licenses/ISC)
*/

/**
 * @file
 * Performs loading of the server.
 */

import axios from "axios";
import nextTick from "next-tick";
import { DeferredPromise } from "../common/async";
import { appUrl } from "../common/defaults";
import { UrlPath } from "../common/url";
import { MaybeDefined, hasOwnProperty } from "../common/utility-types";
import { Application } from "../core/application";
import { CoreArgIds, CoreArgMeta, coreArgMetaGenerate } from "../core/arg";
import { LogLevel } from "../core/error";
import { CoreShardArg } from "../core/shard";
import { RootType, YamlOptions, compile, yamlOptions } from "../yaml";
import { Module, ModuleFactoryRecordList, ModuleFactoryRecordListConstraint, ModuleList } from "./module";
import { ServerOptions, serverOptions } from "./options";
import { ServerUniverse } from "./universe";

/**
 * Yaml entry to register into loader.
 */
export type YamlEntry<T extends string> = {
	/**
	 * Path to yaml file or URL.
	 */
	path: string;

	/**
	 * Path type.
	 */
	type: T;
};

/**
 * Reader type.
 */
export type Reader = (path: string) => Promise<string>;

/**
 * Loader class.
 */
export class ServerLoader<R extends string, T extends ModuleFactoryRecordListConstraint<T>> {
	/**
	 * Application this resides in.
	 */
	private application: Application;

	/**
	 * Default yaml file.
	 */
	private static defaultYaml: string = "";

	private readers: Map<R | "url", Reader> = new Map([
		[
			"url" as const,
			async (data: string): Promise<string> => (await axios.get<string>(data, { responseType: "text" })).data
		]
	]);

	/**
	 * Factory records from constructor.
	 */
	private records: ModuleFactoryRecordList;

	/**
	 * UUIDs are not used, as they are not generated by the application for client.
	 */
	private yamlList: Map<string, YamlEntry<R | "url">> = new Map();

	/**
	 * Adds modules to loader.
	 *
	 * @param list - List of module factory records
	 * @remarks
	 * Safety comes from type constraint, so unnecessary checks omitted.
	 * By design, depends might contain irrelevant keys, and this function accounts for that.
	 */
	public constructor({
		readers,
		application,
		records,
		yamlList
	}: {
		/**
		 * Application.
		 */
		application: Application;

		/**
		 * Factory records list.
		 */
		records: T;

		/**
		 * List of yaml files.
		 */
		yamlList: {
			[key: string]: YamlEntry<R>;
		};
	} & MaybeDefined<
		[Exclude<R, "url">] extends [never] ? false : true,
		{
			/**
			 * Readers.
			 */
			readers: {
				[K in Exclude<R, "url">]: Reader;
			} & {
				/**
				 * URL reader.
				 */
				url?: Reader;
			};
		}
	>) {
		if (readers) {
			Object.keys(readers).forEach(k => {
				// Casting from generic
				this.readers.set(k as keyof typeof readers, readers[k as keyof typeof readers]);
			});
		}
		this.application = application;
		// Reverting from generic to concrete type
		this.records = records as unknown as ModuleFactoryRecordList;
		// "key" must exist in list, as it is retrieved from it
		// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
		this.yamlList = new Map(Object.getOwnPropertyNames(yamlList).map(key => [key, yamlList[key]!]));
	}

	/**
	 * Add server universe.
	 *
	 * @param param - Destructured parameter
	 * @returns Created universe
	 */
	public async addUniverse({
		yamlId
	}: {
		/**
		 * ID of YAML.
		 */
		yamlId: string;
	}): Promise<ServerUniverse> {
		/**
		 * List of kinds to register IDs.
		 */
		type KindList = Partial<Record<string, Partial<Record<string, string>>>>;

		const universeCreated: DeferredPromise<void> = new DeferredPromise();
		const universe: ServerUniverse = this.application.addUniverse({
			Universe: ServerUniverse,
			args: [
				{
					created: universeCreated
				}
			]
		});
		await universeCreated;

		const yamlEntry: YamlEntry<R | "url"> | undefined = this.yamlList.get(yamlId);
		let data: string;
		// Breaking out of if statement to avoid unnecessary undefined assertion
		// eslint-disable-next-line no-restricted-syntax, no-labels
		readFile: try {
			if (yamlEntry) {
				const reader: Reader | undefined = this.readers.get(yamlEntry?.type);
				if (reader) {
					data = await reader(yamlEntry.path);

					// eslint-disable-next-line no-labels
					break readFile;
				}
			}

			throw new Error("YAML not found");
		} catch (error) {
			universe.log({
				error: new Error(`Could not load YAML file with ID(yamlId="${yamlId}").`, {
					cause: error instanceof Error ? error : undefined
				}),
				level: LogLevel.Error
			});
			data = ServerLoader.defaultYaml;
		}
		const root: RootType = compile({ data });
		// Module to kind name to ID
		// eslint-disable-next-line @typescript-eslint/typedef
		const kindList: KindList = Object.entries(root.kinds).reduce((result, [id, { module, name }]) => {
			let newResult: KindList = result;
			if (!hasOwnProperty(newResult, module)) {
				newResult[module] = {
					[name]: id
				};
			} else {
				// Assertion performed with "hasOwnProperty"
				// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
				newResult[module]![name] = id;
			}

			return newResult;
		}, {});
		let moduleList: ModuleList = {};

		// Iterate through records
		this.records.forEach(record => {
			const {
				name: moduleName
			}: {
				/**
				 * Name of module.
				 */
				name: string;
			} = record;
			const module: Module = record.factory({
				moduleName,
				// False negative on type inference
				// eslint-disable-next-line @typescript-eslint/typedef
				modules: Object.entries(record.depends).reduce((result, [key, value]) => {
					let moduleValue: Module | undefined = moduleList[value];
					if (moduleValue) {
						return { ...result, [key]: moduleValue };
					}
					universe.log({
						error: new Error(`Module dependency("${value}") for module("${moduleName}") not found`),
						level: LogLevel.Alert
					});
					return result;
				}, {} as ModuleList),
				universe
			});
			const kindListEntry: KindList[string] = kindList[moduleName];
			const moduleKinds: Module["kinds"] = module.kinds;

			// Populate module list
			moduleList[moduleName] = module;

			// Add messages to universe
			if (module.messages) {
				universe.messages[moduleName] = module.messages;
			}

			// Register kinds
			Object.keys(moduleKinds).forEach(kindName => {
				let id: string;
				let namespace: UrlPath;
				let kindId: string | undefined;
				// Using assignment inside condition simplifies logic dramatically
				// eslint-disable-next-line no-cond-assign
				if (kindListEntry && (kindId = kindListEntry[kindName])) {
					id = kindId;
					namespace = "user";
				} else {
					id = kindName;
					namespace = `kind/${moduleName}`;
				}

				// "kindName" is retrieved as key already
				// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
				universe.Entity.addKind({ Kind: module.kinds[kindName]!, id, namespace });
			});
		});

		await Promise.all(
			root.data.shards.map(
				(shard, index) =>
					new Promise<void>(methodResolve => {
						// Add shards
						let attachHook: Promise<void> = new Promise((resolve, reject) => {
							let created: DeferredPromise<void> = new DeferredPromise<void>();
							nextTick(() => {
								let meta: CoreArgMeta<CoreArgIds.Shard, YamlOptions, ServerOptions> = coreArgMetaGenerate({
									childPath: shard,
									id: CoreArgIds.Shard,
									index,
									meta: {
										origin: appUrl,
										paths: {},
										systemNamespace: "system",
										userNamespace: "user"
									},
									sourceOptions: yamlOptions,
									targetOptions: serverOptions
								});
								let arg: CoreShardArg<ServerOptions> = universe.Shard.convertShard({
									meta,
									shard,
									sourceOptions: yamlOptions,
									targetOptions: serverOptions
								});

								universe.addShard(arg, { attachHook, created }, []);

								created
									.then(() => {
										resolve();
									})
									.catch(() => {
										reject();
									})
									.finally(() => {
										methodResolve();
									});
							});
						});
					})
			)
		);

		return universe;
	}
}
